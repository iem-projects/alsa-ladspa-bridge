/*
 * Copyright (c) 2008 Cooper Street Innovations
 * 		<charles@cooper-street.com>
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 */

/* nomenclature of in/out,...
 *    inchannel    : read-only "input" data (as produced by a microphone or an application, before being passed to us)
 *    outchannel   : write-only "output" data (will be send to soundcard or an application, generated by us)
 *    sourcechannel: channel being passed from soundcard to application
 *    sinkchannel  : channel being passed from application to soundcard (has the same number of in- and outchannels)
 *
 * the LADSPA-plugin must have
 *    (source.inchannels +sink.inchannels ) inputs
 *    (source.outchannels+sink.outchannels) outputs
 *
 *    for simplicity reasons source.inchannels==source.outchannels (same for sink)
 */

#include <stdio.h>
#include <alsa/asoundlib.h>
#include <alsa/pcm.h>
#include <alsa/pcm_external.h>
#include <alsa/control.h>
#include <linux/soundcard.h>

#include <ladspa.h>
#include "ladspa_utils.h"

static void print_pcm_extplug(snd_pcm_extplug_t*ext) {

  printf("EXTPLUG: %p\n", ext);
  printf("EXTPLUG: name=%s\n", ext->name);
  printf("EXTPLUG: version=%d\n", ext->version);
  printf("EXTPLUG: callback=%p\n", ext->callback);
  printf("EXTPLUG: private_data=%p\n", ext->private_data);
  printf("EXTPLUG: pcm=%p\n", ext->pcm);
  printf("EXTPLUG: stream=%d\n", ext->stream);
  printf("EXTPLUG: format=%d\n", ext->format);
  printf("EXTPLUG: subformat=%d\n", ext->subformat);
  printf("EXTPLUG: channels=%d\n", ext->channels);
  printf("EXTPLUG: rate=%d\n", ext->rate);
  printf("EXTPLUG: slave_format=%d\n", ext->slave_format);
  printf("EXTPLUG: slave_subformat=%d\n", ext->slave_subformat);
  printf("EXTPLUG: slave_channels=%d\n", ext->slave_channels);
  printf("\n");
}

static void print_pcm_config(snd_config_t*config, const char*name) {
  int err;
  const char*str;

  printf("SNDCONFIG[%p]: '%s'=[%d]\n", config, name, snd_config_get_type(config));
  err=snd_config_get_id(config, &str);
  printf("SNDCONFIG[%p]: id[%d]=%s\n", config, err, str);
  err=snd_config_get_string(config, &str);
  printf("SNDCONFIG[%p]: string[%d]=%s\n", config, err, str);
}

typedef struct _iemladspa_audiobuf {
  unsigned int frames;
  unsigned int channels;
  size_t size;
  float *data;
} iemladspa_audiobuf_t;

typedef struct snd_pcm_iemladspa {
	snd_pcm_extplug_t ext;
	void *library;
	const LADSPA_Descriptor *klass;

  iemladspa_audiobuf_t inbuf ;
  iemladspa_audiobuf_t outbuf;
  int stream_direction;

	LADSPA_Control *control_data;
	LADSPA_Handle *plugininstance;
} snd_pcm_iemladspa_t;

static void audiobuffer_free(iemladspa_audiobuf_t *iemladspa) {
  if(iemladspa->data)free(iemladspa->data);
  iemladspa->data=NULL;
  iemladspa->frames=0;
  iemladspa->channels=0;
  iemladspa->size=0;
}

static int audiobuffer_resize(iemladspa_audiobuf_t *buf, unsigned int frames, unsigned int channels) {
  size_t size=frames*channels;
  if(size > buf->size) {
    float*data=NULL;
    size*=2; /* over-allocation */
    data=realloc(buf->data, size*sizeof(float));
    if(!data) {
      audiobuffer_free(buf);
      return 0;
    }
    buf->data=data;
    buf->size = size;
  }
  if(frames != buf->frames || channels != buf->channels) {
    /* frames/channels have changed, clear the buffer */
    memset(buf->data, 0, size*sizeof(float));
  }
  buf->frames=frames;
  buf->channels=channels;
  return 1;
}

static inline void interleave(float *src, float *dst, int frames, int channels)
{
	int i, j;
	for(i = 0; i < frames; i++){
		for(j = 0; j < channels; j++){
			dst[i*channels + j] = src[i + frames*j];
		}
	}
}

static inline void deinterleave(float *src, float *dst, int frames, int channels)
{
	int i, j;
	for(i = 0; i < frames; i++){
		for(j = 0; j < channels; j++){
			dst[i + frames*j] = src[i*channels + j];
		}
	}
}

static inline void connect_port(snd_pcm_iemladspa_t *iemladspa,
                         unsigned long Port,
                         LADSPA_Data * DataLocation,
                         const char*name) {
  printf("connect %s\t %lu to %p\n", name, Port, DataLocation);
  iemladspa->klass->connect_port(iemladspa->plugininstance,
                               Port, DataLocation);
}

static snd_pcm_sframes_t iemladspa_transfer(snd_pcm_extplug_t *ext,
		  const snd_pcm_channel_area_t *dst_areas,
		  snd_pcm_uframes_t dst_offset,
		  const snd_pcm_channel_area_t *src_areas,
		  snd_pcm_uframes_t src_offset,
		  snd_pcm_uframes_t size)
{
	snd_pcm_iemladspa_t *iemladspa = (snd_pcm_iemladspa_t *)(ext->private_data);
  const int playback = (SND_PCM_STREAM_PLAYBACK == ext->stream);

	int j;
  const unsigned long dataoffset_in  = iemladspa->control_data->num_controls;
  const unsigned long dataoffset_out = dataoffset_in + iemladspa->control_data->num_inchannels;

  const unsigned int inchannels  = (playback)?(iemladspa->control_data->sourcechannels.in ):(iemladspa->control_data->sinkchannels.in);
  const unsigned int outchannels = (playback)?(iemladspa->control_data->sourcechannels.out):(iemladspa->control_data->sinkchannels.out);

  const unsigned long bufoffset_in  = (playback)?(iemladspa->control_data->sourcechannels.in  * size):0;
  const unsigned long bufoffset_out = (playback)?(iemladspa->control_data->sourcechannels.out * size):0;

	/* Calculate buffer locations */
	float *src = (float*)(src_areas->addr +
			(src_areas->first + src_areas->step * src_offset)/8);
	float *dst = (float*)(dst_areas->addr +
			(dst_areas->first + dst_areas->step * dst_offset)/8);	


  /* make sure out deinterleaving buffers are large enough */
  audiobuffer_resize(&iemladspa->inbuf , size,
                     iemladspa->control_data->sourcechannels.in +iemladspa->control_data->sinkchannels.in);
  audiobuffer_resize(&iemladspa->outbuf, size,
                     iemladspa->control_data->sourcechannels.out+iemladspa->control_data->sinkchannels.out);

	/* NOTE: swap source and destination memory space when deinterleaved.
		then swap it back during the interleave call below */
  deinterleave(src,
               iemladspa->inbuf.data + bufoffset_in,
               size, inchannels);

  /* only run when stream is in playback mode */
  if(playback) {
    for(j = 0; j < iemladspa->control_data->num_inchannels; j++) {
      connect_port(iemladspa,
                   iemladspa->control_data->data[dataoffset_in + j].index,
                   iemladspa->inbuf.data + j*size,
                   "inport "
                   );
    }
    for(j = 0; j < iemladspa->control_data->num_outchannels; j++) {
      connect_port(iemladspa,
                   iemladspa->control_data->data[dataoffset_out+ j].index,
                   iemladspa->outbuf.data + j*size,
                   "outport");
    }

    iemladspa->klass->run(iemladspa->plugininstance, size);
  }

  //printf("instance=%p\tstream=%d\n", iemladspa->plugininstance, ext->stream);

	interleave(iemladspa->outbuf.data + bufoffset_out,
             dst,
             size, outchannels);

  iemladspa->stream_direction = ext->stream;
	return size;
}

static int iemladspa_close(snd_pcm_extplug_t *ext) {
	snd_pcm_iemladspa_t *iemladspa = (snd_pcm_iemladspa_t*)ext->private_data;
  print_pcm_extplug(ext);

  if(iemladspa->klass->deactivate) {
    iemladspa->klass->deactivate(iemladspa->plugininstance);
  }


#if 0
  /* TODO: Figure out why this segfaults */
  if(iemladspa->klass->cleanup) {
    iemladspa->klass->cleanup(iemladspa->plugininstance);
  }
#endif

	LADSPAcontrolUnMMAP(iemladspa->control_data);
	LADSPAunload(iemladspa->library);
	free(iemladspa);
	return 0;
}

static LADSPA_Handle *s_plugininstance=NULL;
static int iemladspa_init(snd_pcm_extplug_t *ext)
{
	snd_pcm_iemladspa_t *iemladspa = (snd_pcm_iemladspa_t *)ext->private_data;
	int i;

  //print_pcm_extplug(ext);

	/* Instantiate a LADSPA Plugin */
  if(!s_plugininstance) {
    s_plugininstance=iemladspa->klass->instantiate(iemladspa->klass, ext->rate);
  }

  iemladspa->plugininstance = s_plugininstance;
  if(iemladspa->plugininstance == NULL) {
    return -1;
  }
  if(iemladspa->klass->activate) {
    iemladspa->klass->activate(iemladspa->plugininstance);
  }

	/* Connect controls to the LADSPA Plugin */
  for(i = 0; i < iemladspa->control_data->num_controls; i++) {
    iemladspa->klass->connect_port(iemladspa->plugininstance,
                                 iemladspa->control_data->data[i].index,
                                 &iemladspa->control_data->data[i].data);
		}

  audiobuffer_resize(&iemladspa->inbuf,
                     65536,
                     iemladspa->control_data->sourcechannels.in+iemladspa->control_data->sinkchannels.in);
  audiobuffer_resize(&iemladspa->outbuf,
                     65536,
                     iemladspa->control_data->sourcechannels.out+iemladspa->control_data->sinkchannels.out);

	return 0;
}

static snd_pcm_extplug_callback_t iemladspa_callback = {
	.transfer = iemladspa_transfer,
	.init = iemladspa_init,
	.close = iemladspa_close,
};

SND_PCM_PLUGIN_DEFINE_FUNC(iemladspa)
{
	snd_config_iterator_t i, next;
	snd_pcm_iemladspa_t *iemladspa=NULL;
	snd_config_t *sconf = NULL;
	const char *controls = ".alsaiemladspa.bin";
	const char *library = "/usr/lib/ladspa/iemladspa.so";
	const char *module = "iemladspa";
	int err;
  iemladspa_iochannels_t sourcechannels, sinkchannels;
  long inchannels = 2;
  long outchannels = 2;

	/* Parse configuration options from asoundrc */
	snd_config_for_each(i, next, conf) {
		snd_config_t *n = snd_config_iterator_entry(i);
		const char *id;
		if (snd_config_get_id(n, &id) < 0)
			continue;
		if (strcmp(id, "comment") == 0 || strcmp(id, "type") == 0 || strcmp(id, "hint") == 0)
			continue;
		if (strcmp(id, "slave") == 0) {
			sconf = n;
			continue;
		}
		if (strcmp(id, "controls") == 0) {
			snd_config_get_string(n, &controls);
			continue;
		}
		if (strcmp(id, "library") == 0) {
			snd_config_get_string(n, &library);
			continue;
		}
		if (strcmp(id, "module") == 0) {
			snd_config_get_string(n, &module);
			continue;
		}
		if (strcmp(id, "inchannels") == 0) {
      snd_config_get_integer(n, &inchannels);
      if(inchannels < 1) {
        SNDERR("inchannels < 1");
        return -EINVAL;
      }
      continue;
		}
		if (strcmp(id, "outchannels") == 0) {
      snd_config_get_integer(n, &outchannels);
      if(outchannels < 1) {
        SNDERR("outchannels < 1");
        return -EINVAL;
      }
      continue;
		}

		SNDERR("Unknown field %s", id);
		return -EINVAL;
	}
  sourcechannels.in = sourcechannels.out = inchannels;
  sinkchannels.in   = sinkchannels.out   = outchannels;

  printf("channels= %d/%d + %d/%d\n", sourcechannels.in, sourcechannels.out, sinkchannels.in, sinkchannels.out);

  if(1) {
    const void*id=NULL;
    snd_config_get_pointer(sconf, &id);
    printf("SLAVE: %p = %d\n", id, snd_config_get_type(sconf));
  }
	/* Make sure we have a slave and control devices defined */
	if (! sconf) {
		SNDERR("No slave configuration for iemladspa pcm");
		return -EINVAL;
	}

	/* Intialize the local object data */
	iemladspa = calloc(1, sizeof(*iemladspa));
	if (iemladspa == NULL)
		return -ENOMEM;

	iemladspa->ext.version = SND_PCM_EXTPLUG_VERSION;
	iemladspa->ext.name = "alsaiemladspa";
	iemladspa->ext.callback = &iemladspa_callback;
	iemladspa->ext.private_data = iemladspa;

  iemladspa->stream_direction = -1;

	/* Open the LADSPA Plugin */
	iemladspa->library = LADSPAload(library);
  printf("LADSPAlib: %p\n", iemladspa->library);
	if(iemladspa->library == NULL) {
		return -1;
	}

	iemladspa->klass = LADSPAfind(iemladspa->library, library, module);
  printf("LADSPAklass: %p\n", iemladspa->klass);

	if(iemladspa->klass == NULL) {
		return -1;
	}

  print_pcm_config(root, "root");
  print_pcm_config(sconf, "sconf");

	/* Create the ALSA External Plugin */
  printf("creating external plugin %p/%p\t%d/%d\n", root, sconf, stream, mode);
	err = snd_pcm_extplug_create(&iemladspa->ext, name, root, sconf, stream, mode);
	if (err < 0) {
    printf("extplug failed\n");
		return err;
	}

  //printf("ROOT:\n"); print_pcm_extplug(&iemladspa->ext); printf(":ROOT \n");


	/* MMAP to the controls file */
  iemladspa->control_data = LADSPAcontrolMMAP(iemladspa->klass, controls,
                                            sourcechannels, sinkchannels);
	if(iemladspa->control_data == NULL) {
		return -1;
	}

	/* Make sure that the control file makes sense */
  unsigned int j;

  const unsigned long offset_in = iemladspa->control_data->num_controls;
  const unsigned long offset_out = offset_in + iemladspa->control_data->num_inchannels;

  for(j=0; j<iemladspa->control_data->num_inchannels; j++) {
    unsigned int index=iemladspa->control_data->data[offset_in + j].index;
    if(index>=iemladspa->klass->PortCount || iemladspa->klass->PortDescriptors[index] !=
       (LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO)) {
      SNDERR("Problem with control file %s.", controls);
      return -1;
    }
  }
  for(j=0; j<iemladspa->control_data->num_outchannels; j++) {
    unsigned int index=iemladspa->control_data->data[offset_out+ j].index;

    if(index>=iemladspa->klass->PortCount || iemladspa->klass->PortDescriptors[index] !=
       (LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO)) {
      SNDERR("Problem with control file %s.", controls);
      return -1;
    }
  }

	/* Set PCM Contraints */
  unsigned int channels = (SND_PCM_STREAM_PLAYBACK == stream)
    ? iemladspa->control_data->sourcechannels.out
    : iemladspa->control_data->sinkchannels.in;

  snd_pcm_extplug_set_param_minmax(&iemladspa->ext,
                                   SND_PCM_EXTPLUG_HW_CHANNELS,
                                   channels,
                                   channels);

  snd_pcm_extplug_set_slave_param(&iemladspa->ext,
                                  SND_PCM_EXTPLUG_HW_CHANNELS,
                                  channels);

	snd_pcm_extplug_set_param(&iemladspa->ext,
			SND_PCM_EXTPLUG_HW_FORMAT, SND_PCM_FORMAT_FLOAT);

	snd_pcm_extplug_set_slave_param(&iemladspa->ext,
			SND_PCM_EXTPLUG_HW_FORMAT, SND_PCM_FORMAT_FLOAT);

	*pcmp = iemladspa->ext.pcm;
	
	return 0;

}

SND_PCM_PLUGIN_SYMBOL(iemladspa);

